
# ğŸ§  Racional de Arquitetura e Tecnologias Utilizadas â€“ Glina MVP

O MVP da Glina foi projetado com foco em **velocidade de desenvolvimento, simplicidade operacional, seguranÃ§a e escalabilidade futura**. A seguir explico as decisÃµes tÃ©cnicas e por que cada tecnologia foi escolhida.

---

## ğŸ”§ Backend â€” Node.js + TypeScript + Serverless Framework

### Por que Node.js + TypeScript?
- Permite alta produtividade com uma curva de aprendizado suave.
- Ecossistema maduro com bibliotecas robustas.
- TypeScript oferece seguranÃ§a com tipagem estÃ¡tica, reduzindo bugs e aumentando a confiabilidade do cÃ³digo.
- A equipe tÃ©cnica (atual e futura) tende a ter familiaridade com esse stack.

### Por que Serverless Framework (com AWS Lambda)?
- Ideal para MVPs: permite escalar sob demanda, sem precisar manter infraestrutura.
- Custo zero quando nÃ£o hÃ¡ uso.
- Foco em escrever cÃ³digo de negÃ³cio, deixando o provisionamento e deployment por conta do framework.
- Facilita deploys futuros para ambientes como AWS ou Vercel.

---

## ğŸ§¬ Banco de Dados â€” PostgreSQL + Prisma ORM

### Por que PostgreSQL?
- Ã‰ um banco relacional poderoso, confiÃ¡vel e com suporte a tipos complexos, transaÃ§Ãµes, JSON, etc.
- Tem suporte excelente na nuvem (RDS, Supabase, Neon, etc).

### Por que Prisma?
- Oferece tipagem forte, DX excelente e geraÃ§Ã£o automÃ¡tica de clientes fortemente tipados.
- Suporta `migrations`, `seed`, validaÃ§Ãµes, e evita SQL injection.
- Ideal para um sistema que precisa evoluir rapidamente com seguranÃ§a.

---

## ğŸ”‘ AutenticaÃ§Ã£o â€” JWT

### Por que JWT e nÃ£o Cognito (por enquanto)?
- JWT Ã© simples de implementar e suficiente para as necessidades de um MVP.
- Cognito adiciona complexidade e custo inicial (ideal em estÃ¡gios futuros).
- Tokens sÃ£o gerados e verificados no backend, com expiraÃ§Ã£o e verificaÃ§Ã£o via middleware.

---

## ğŸ“¦ Containers â€” Docker + Docker Compose

### Por que usar Docker?
- Garante que qualquer pessoa consiga rodar o projeto localmente com um simples `docker compose up`.
- Elimina problemas de â€œfunciona na minha mÃ¡quinaâ€.
- Permite simular a infraestrutura de produÃ§Ã£o localmente (API + banco + frontend).

---

## ğŸ§‘â€ğŸ’» Frontend â€” Next.js (React) + TypeScript

### Por que Next.js?
- Framework maduro e pronto para produÃ§Ã£o.
- Suporta SSR, API Routes e fÃ¡cil deploy na Vercel.
- Times modernos jÃ¡ usam amplamente.

### Por que TypeScript no frontend tambÃ©m?
- UnificaÃ§Ã£o da stack com o backend.
- Tipagem ajuda a reduzir bugs em integraÃ§Ã£o com a API.
- Permite escalar o time mantendo consistÃªncia de cÃ³digo.

---

## ğŸŒ IntegraÃ§Ã£o com Parceiros (mock)

- As transaÃ§Ãµes financeiras sÃ£o feitas via **parceiros externos** (por exemplo, serviÃ§os de offshore investment).
- Neste MVP, as chamadas foram isoladas em uma camada de integraÃ§Ã£o (`services/parceiros`) para facilitar futura substituiÃ§Ã£o por APIs reais.
- Esse design permite mockar comportamentos agora e evoluir sem reescrever regras de negÃ³cio.

---

## ğŸ”’ SeguranÃ§a MÃ­nima

- Dados sensÃ­veis como senhas sÃ£o criptografados com `bcrypt`.
- JWT com expiraÃ§Ã£o e assinatura segura (`JWT_SECRET`).
- SeparaÃ§Ã£o clara de permissÃµes: usuÃ¡rios e admins.
- Estrutura pronta para evoluir para compliance LGPD e GDPR (ex: logs, consentimento, exclusÃ£o de dados).

---

## ğŸ§© ConclusÃ£o

O stack foi pensado para **acelerar o tempo de entrega sem sacrificar a seguranÃ§a, a legibilidade e a escalabilidade futura**.  
Cada escolha tem justificativa clara dentro do estÃ¡gio atual da Glina, mas tambÃ©m aponta para o crescimento da empresa com bases sÃ³lidas.